name: Build and Test

on:
  push:
    branches: ['alexandre_assignment2']
  pull_request:
    branches: ['alexandre_assignment2']

jobs:
  # Normal build + test
  build_and_test:
    name: Normal build and test
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository (This copies the repo into the virtual machine)
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Install necessary tools (here we have to use the package manager of ubuntu not Arch!)
      # Use sudo apt-get which will check the cache for .deb files
      - name: Install build dependencies
        run: sudo apt-get update && sudo apt-get install -y cmake build-essential doxygen libvtk9-dev

      # Step 3: Cache APT packages to speed up installs. This Caches the downloaded packages locally to avoid permission issues
      # This cache can be accessed acoss branches.
      # This avoids the long downloads from mirrors every time the workflows run.
      # The "|" isn't an OS pipe but indicates a multiline string literal
      - name: Cache APT packages
        uses: actions/cache@v4
        with:
            path: ${{ github.workspace }}/apt-cache
            key: ${{ runner.os }}-apt-${{ hashFiles('.github/workflows/*.yml') }}
            restore-keys: |
              ${{ runner.os }}-apt-

      # Step 4: Cache CMake configuration (This caches the result of the terminal command: $ cmake -S - -B build)
      # Because the cache key is determined by "${{ hashFiles('**/CMakeLists.txt', '**/*.cmake') }}" changes to the source files do not invalidate the cache.
      # Only changing any of the CMakeLists.txt or *.cmake files invalidate the cache.
      - name: Cache CMake configuration
        uses: actions/cache@v4
        with:
          path: |
           build/CMakeCache.txt
           build/CMakeFiles
          key: ${{ runner.os }}-cmake-${{ hashFiles('**/CMakeLists.txt', '**/*.cmake') }}
          restore-keys: |
            ${{ runner.os }}-cmake-
      # the last line makes the runner use an older cache if there isn't an exact match. This avoids full cache misses.

      # Step 5: Cache external dependencies (FetchContent libraries such as google test get cached inbetween runs speeding up the entire job)
      # Because the cache key is determined by "${{ hashFiles('**/CMakeLists.txt', '**/*.cmake') }}" changes to the source files do not invalidate the cache.
      # Only changing any of the CMakeLists.txt or *.cmake files invalidate the cache.
      - name: Cache external dependencies
        uses: actions/cache@v4
        with:
          path: build/_deps
          key: ${{ runner.os }}-deps-${{ hashFiles('**/CMakeLists.txt', '**/*.cmake') }}
          restore-keys: |
                 ${{ runner.os }}-deps-
      # the last line makes the runner use an older cache if there isn't an exact match. This avoids full cache misses.

      # Step 6: Configure CMake (needed to generate build system)
      - name: Configure project
        run: cmake -S . -B build

      # Step 7: build with generated makefiles and use all available cores
      - name: Build project
        run: cmake --build build -- -j$(nproc)

      # Step 8: build the documentation
      - name: Build documentation
        run: cmake --build build --target doc_doxygen

      # waiting for Altays work on Google tests
      #- name: Run unit tests
      #  run: ctest --test-dir build --output-on-failure -j$(nproc)

  # ASan build + test which is done as its own job to start with a fresh VM
  build_and_test_asan:
    name: AddressSanitizer build and test
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository (This copies the repo into the virtual machine)
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Install necessary tools (here we have to use the package manager of ubuntu not Arch!)
      - name: Install build dependencies
        run: sudo apt-get update && sudo apt-get install -y cmake build-essential libvtk9-dev

      # Step 3: Use Cached APT .deb files. Other Caches won't be used to have a clean Sanitizer build.
      - name: Cache APT packages
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/apt-cache
          key: ${{ runner.os }}-apt-${{ hashFiles('.github/workflows/*.yml') }}
          restore-keys: |
            ${{ runner.os }}-apt-

      # Step 4: Configure CMake (needed to generate build system). Here we pass extra flags for sanitizing, hence also a separate build.
      - name: Configure ASan build
        run: |
          cmake -S . -B build_asan \
                -DCMAKE_BUILD_TYPE=Debug \
                -DCMAKE_C_FLAGS="-fsanitize=address -O1 -fno-omit-frame-pointer -g" \
                -DCMAKE_CXX_FLAGS="-fsanitize=address -O1 -fno-omit-frame-pointer -g"

      # Step 5: build with generated makefiles and use all available cores
      - name: Build ASan project
        run: cmake --build build_asan -- -j$(nproc)

      # Step 6: probably unnecessary as test were already run on normal build job
      #- name: Run ASan tests
      #  run: ctest --test-dir build_asan --output-on-failure -j$(nproc)